#!/usr/bin/env ruby
# frozen_string_literal: true

require 'thor'
require 'sqlite3'
require 'digest'
require 'time'
require 'fileutils'
require 'socket'
require 'shellwords'

# HAKEMISTO class: scans contents of a dir and counts checksums.
class Hakemisto < Thor
  default_task :default
  # alias d = duplicate/tupla, def = default/oletus, l/lukossa = locked, m/puuttuu = missing, r = roina

  desc 'default', 'default function.'
  def default(dir = nil)
    polku = path_new
    FileUtils.cd(dir) unless dir.nil?
    db = db_read('hakemisto.db') if File.exist?('hakemisto.db')
    uusi = db_read(polku) # new db
    uusi.execute("CREATE TABLE IF NOT EXISTS Documents (status TEXT, ls_time DATETIME, summa TEXT, path TEXT);")
    insert = 'INSERT INTO Documents (status, ls_time, summa, path) values'
    uusi.execute("#{insert} ('DIR', '#{Time.now}', '0,0', 'hostname:#{polku}')")
    Dir.glob("**/*.*").each do |f|
      if !File.directory?(f)
        count = 0
        checksums = summa(f)
        count = db.execute("SELECT * FROM Documents WHERE summa='#{checksums}';").count if File.exist?('hakemisto.db')
        uusi.execute("#{insert} ('#{status(f, count)}', '#{File.stat(f).mtime}', '#{checksums}', \"#{f}\");")
      end
    end
    uusi&.close
    db&.close if File.exist?('hakemisto.db')
    FileUtils.mv(polku, './hakemisto.db')
    File.delete(polku) if File.exist?(polku)
    puts polku
  end

  desc 'duplicate', 'look for duplicates in the DB.'
  def duplicate(filename = nil)
    db_file = ENV['DB'] || 'hakemisto.db'
    db = db_read(db_file) # non-changing
    if filename.nil?
      db.execute("SELECT * FROM Documents WHERE status='D2';") do |l| puts l.to_s; end
      db.execute("SELECT * FROM Documents WHERE status='L2';") do |l| puts l.to_s; end
      db.execute("SELECT * FROM Documents WHERE status='M2';") do |l| puts l.to_s; end
      # db.execute("SELECT * FROM Documents WHERE status='R2';") do |l| puts l.to_s; end
    else
      checksums = summa(filename)
      db.execute("SELECT * FROM Documents WHERE summa='#{checksums}';") do |l| puts l.to_s; end
    end
    db&.close
  end

  desc 'locked', 'look for locked files in the DB.'
  def locked(filename = nil)
    db_file = ENV['DB'] || 'hakemisto.db'
    db = db_read(db_file) # non-changing, is this line needed?
    if filename.nil?
      db.execute("SELECT * FROM Documents WHERE status='L2';") do |l| puts l.to_s; end
      db.execute("SELECT * FROM Documents WHERE status='LL';") do |l| puts l.to_s; end
    else #
      db.execute("SELECT * FROM Documents WHERE path='#{filename}';") do |l| puts l.to_s; end
    end
    db&.close
  end

  desc 'missing', 'look for missing files in the DB.'
  def missing(filename = nil)
    db_file = ENV['DB'] || 'hakemisto.db' # pwd
    db = db_read(db_file) # non-changing, is this line needed?
    if filename.nil?
      db.execute("SELECT * FROM Documents WHERE status='MM';") do |l| puts l.to_s; end
      db.execute("SELECT * FROM Documents WHERE status='M2';") do |l| puts l.to_s; end
    else
      db.execute("SELECT * FROM Documents WHERE path='#{filename}';") do |l| puts l.to_s; end
    end
    db&.close
  end

  desc 'roina', 'look for roina files in the DB.'
  def roina(filename = nil)
    db_file = ENV['DB'] || 'hakemisto.db'
    db = db_read(db_file) # non-changing, is this line needed?
    if filename.nil?
      # db.execute("SELECT * FROM Documents WHERE status='R2';") do |l| puts l.to_s; end
      db.execute("SELECT * FROM Documents WHERE status='RR';") do |l| puts l.to_s; end
    else
      db.execute("SELECT * FROM Documents WHERE path='#{filename}';") do |l| puts l.to_s; end
    end
    db&.close
  end

  desc 'this_machine', 'checks if given DB was created on this machine (NOTE: work in progress).'
  def this_machine(filename = nil)
    db_file = filename || ENV['DB'] || 'hakemisto.db'
    db = db_read(db_file) # non-changing?
    line = db.execute("SELECT * FROM Documents WHERE status='DIR';")
    db&.close
    true if line.to_s.include?(Socket.gethostname)
    false # boolean method?
  end

  private

  def db_read(file)
    SQLite3::Database.open file # howto do read-only?
  end

  def locked?(filepath)
    if RUBY_PLATFORM.include?('darwin')
      line = `ls -lO #{Shellwords.escape(filepath)}`.to_s # strip extra spaces/tabs
      return true if line.include?(' uchg ')
    end
    false
  end

  def missing?(filepath)
    # db_z = db_read("asetus dir:temp/z.db")
    # true if db_z.execute("SELECT * FROM Documents WHERE path='#{filepath}';")
    # db_z&.close
    false
  end

  def path_new
    temp =  ENV['TEMP'] || `asetus dir:temp`.gsub("\n", "") || '~/Projects/temp'
    "#{temp}/#{Process.pid}.db"
  end

  def status(filename, count)
    tila = 'NA'
    tila = 'LL' if locked?(filename) && tila == 'NA'
    tila = 'RR' if trash?(filename) && tila == 'NA'
    tila = 'MM' if missing?(filename) && tila == 'NA'
    if count > 1
      tila = 'D2' if tila == 'NA'
      tila = 'L2' if tila == 'LL'
      tila = 'R2' if tila == 'RR'
      tila = 'M2' if tila == 'MM'
    end
    tila = 'OK' if File.exists?('OK.txt') && tila == 'NA' # doesn't work with path
    return tila
  end

  def summa(filename)
    "#{Digest::MD5.file filename},#{Digest::SHA256.file filename}".to_s
  end

  def trash?(filepath)
    return true if filepath.include?('all-wcprops')
    return true if filepath.include?('backup.log')
    return true if filepath.include?('changed.lst')
    return true if filepath.include?('.DS_Store')
    return true if filepath.include?('duplicate.lst')
    return true if filepath.include?('entries')
    return true if filepath.include?('hakemisto.db')
    return true if filepath.include?('hakemisto.lst')
    return true if filepath.include?('missing.lst')
    return true if filepath.include?('OK.txt')
    return true if filepath.include?('roina.lst')
    return true if filepath.include?('Thumbs.db')
    return false
  end
end

Hakemisto.start(ARGV)
